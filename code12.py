# -*- coding: utf-8 -*-
"""Code12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14AFHYj6zdudO5qf2l0mCrD1OWfa9MvmD

##**IMAGE SEGMENTATION:IMPLEMENT DIFFERENT IMAGE SEGMENTATION ALGORITHMS,SUCH AS REGION-BASED SEGMENTATION, EDGE-BASED SEGMENTATION, AND CLUSTERING-BASED SEGMENTATION.**

#Region-Based Segmentation (using GrabCut algorithm):
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load the image
image_path = '/content/image12.jpg'
image = cv2.imread(image_path)

# Create a mask initialized with zeros
mask = np.zeros(image.shape[:2], dtype=np.uint8)

# Define the rectangular region of interest (ROI) for segmentation
rect = (50, 50, 300, 500)

# Apply GrabCut algorithm to segment the image
bgdModel = np.zeros((1, 65), dtype=np.float64)
fgdModel = np.zeros((1, 65), dtype=np.float64)
cv2.grabCut(image, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)

# Create a binary mask where 0 and 2 denote background and 1 and 3 denote foreground
mask = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')

# Apply the mask to extract the segmented region
segmented_image = image * mask[:, :, np.newaxis]

# Display the original image and the segmented image
cv2_imshow(image)
cv2_imshow(segmented_image)

"""# Edge-Based Segmentation (using Canny edge detection):"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load the image
image_path = '/content/image12.jpg'
image = cv2.imread(image_path)

# Convert the image to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection
edges = cv2.Canny(gray, 100, 200)

# Display the original image and the edges
cv2_imshow(image)
cv2_imshow(edges)

"""#Clustering-Based Segmentation (using K-means clustering):"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load the image
image_path = '/content/image12.jpg'
image = cv2.imread(image_path)

# Reshape the image to a 2D array of pixels
pixels = image.reshape(-1, 3)

# Convert the data type to float32
pixels = np.float32(pixels)

# Define the criteria for k-means clustering
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)

# Perform k-means clustering
k = 4  # Number of clusters
_, labels, centers = cv2.kmeans(pixels, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

# Convert the centers to 8-bit values
centers = np.uint8(centers)

# Map each pixel to its corresponding cluster center
segmented_pixels = centers[labels.flatten()]

# Reshape the segmented pixels back to the original image shape
segmented_image = segmented_pixels.reshape(image.shape)

# Display the original image and the segmented image
cv2_imshow(image)
cv2_imshow(segmented_image)

"""#Đánh giá hiệu xuất của chúng bằng các chỉ số định lượng như độ chính xác, độ phủ và chỉ số F1, cũng như đánh giá định tính.

##[ ]Đánh giá Region-Based Segmentation (using GrabCut algorithm)
"""

#đánh giá Region-Based Segmentation (using GrabCut algorithm)
import cv2
import numpy as np

# Load the images
segmented_image_path = '/content/tải xuống.png'
ground_truth_image_path = '/content/image12.jpg'
segmented_image = cv2.imread(segmented_image_path)
ground_truth_image = cv2.imread(ground_truth_image_path)

# Convert the images to grayscale
segmented_gray = cv2.cvtColor(segmented_image, cv2.COLOR_BGR2GRAY)
ground_truth_gray = cv2.cvtColor(ground_truth_image, cv2.COLOR_BGR2GRAY)

# Threshold the images to create binary masks
_, segmented_mask = cv2.threshold(segmented_gray, 0, 255, cv2.THRESH_BINARY)
_, ground_truth_mask = cv2.threshold(ground_truth_gray, 0, 255, cv2.THRESH_BINARY)

# Compute the true positives (tp), false positives (fp), false negatives (fn)
tp = np.sum(segmented_mask & ground_truth_mask)
fp = np.sum(segmented_mask & (~ground_truth_mask))
fn = np.sum((~segmented_mask) & ground_truth_mask)

# Compute the accuracy, recall, and F1 score
accuracy = (tp + np.sum(~segmented_mask & ~ground_truth_mask)) / (segmented_mask.size)
recall = tp / (tp + fn)
precision = tp / (tp + fp)
f1_score = 2 * (precision * recall) / (precision + recall)

print('Accuracy:', accuracy)
print('Recall:', recall)
print('Precision:', precision)
print('F1 score:', f1_score)

"""###[ ]Đánh giá Edge-Based Segmentation (using Canny edge detection)"""

#đánh giá Edge-Based Segmentation (using Canny edge detection)
import cv2
import numpy as np

# Load the images
segmented_image_path = '/content/tải xuống (1).png'
ground_truth_image_path = '/content/image12.jpg'
segmented_image = cv2.imread(segmented_image_path)
ground_truth_image = cv2.imread(ground_truth_image_path)

# Convert the images to grayscale
segmented_gray = cv2.cvtColor(segmented_image, cv2.COLOR_BGR2GRAY)
ground_truth_gray = cv2.cvtColor(ground_truth_image, cv2.COLOR_BGR2GRAY)

# Threshold the images to create binary masks
_, segmented_mask = cv2.threshold(segmented_gray, 0, 255, cv2.THRESH_BINARY)
_, ground_truth_mask = cv2.threshold(ground_truth_gray, 0, 255, cv2.THRESH_BINARY)

# Compute the true positives (tp), false positives (fp), false negatives (fn)
tp = np.sum(segmented_mask & ground_truth_mask)
fp = np.sum(segmented_mask & (~ground_truth_mask))
fn = np.sum((~segmented_mask) & ground_truth_mask)

# Compute the accuracy, recall, and F1 score
accuracy = (tp + np.sum(~segmented_mask & ~ground_truth_mask)) / (segmented_mask.size)
recall = tp / (tp + fn)
precision = tp / (tp + fp)
f1_score = 2 * (precision * recall) / (precision + recall)

print('Accuracy:', accuracy)
print('Recall:', recall)
print('Precision:', precision)
print('F1 score:', f1_score)

"""###[ ]Đánh giá Clustering-Based Segmentation (using K-means clustering)"""

#đánh giá Clustering-Based Segmentation (using K-means clustering))
import cv2
import numpy as np

# Load the images
segmented_image_path = '/content/tải xuống (2).png'
ground_truth_image_path = '/content/image12.jpg'
segmented_image = cv2.imread(segmented_image_path)
ground_truth_image = cv2.imread(ground_truth_image_path)

# Convert the images to grayscale
segmented_gray = cv2.cvtColor(segmented_image, cv2.COLOR_BGR2GRAY)
ground_truth_gray = cv2.cvtColor(ground_truth_image, cv2.COLOR_BGR2GRAY)

# Threshold the images to create binary masks
_, segmented_mask = cv2.threshold(segmented_gray, 0, 255, cv2.THRESH_BINARY)
_, ground_truth_mask = cv2.threshold(ground_truth_gray, 0, 255, cv2.THRESH_BINARY)

# Compute the true positives (tp), false positives (fp), false negatives (fn)
tp = np.sum(segmented_mask & ground_truth_mask)
fp = np.sum(segmented_mask & (~ground_truth_mask))
fn = np.sum((~segmented_mask) & ground_truth_mask)

# Compute the accuracy, recall, and F1 score
accuracy = (tp + np.sum(~segmented_mask & ~ground_truth_mask)) / (segmented_mask.size)
recall = tp / (tp + fn)
precision = tp / (tp + fp)
f1_score = 2 * (precision * recall) / (precision + recall)

print('Accuracy:', accuracy)
print('Recall:', recall)
print('Precision:', precision)
print('F1 score:', f1_score)

"""# Histogram of Segmentation Efficiency"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Initialize data
algorithms = ['Region-Based', 'Edge-Based', 'Clustering-Based']
accuracy = [0.85, 0.75, 0.9]
recall = [0.89, 0.79, 0.92]
precision = [0.88, 0.72, 0.95]
f1_score = [0.88, 0.75, 0.93]

# Create a dataframe
data = {'Algorithm': algorithms,
        'Accuracy': accuracy,
        'Recall': recall,
        'Precision': precision,
        'F1 Score': f1_score}
df = pd.DataFrame(data)

# Melt the dataframe
df_melt = df.melt(id_vars='Algorithm', value_vars=['Accuracy', 'Recall', 'Precision', 'F1 Score'], var_name='Metric')


# Create a histogram
sns.set(style='whitegrid')
g = sns.catplot(x='Algorithm', y='value', hue='Metric', data=df_melt, kind='bar', height=5, aspect=1.5)
g.despine(left=True)
g.set_axis_labels('', 'Metrics')
g.legend.set_title('')
g.fig.suptitle('Histogram of Segmentation Efficiency')
plt.show()

"""#Một số thuật toán khác:Watershed Segmentation,  Mean-Shift Segmentation,Graph-Based Segmentation,  Region Growing Segmentation,  Superpixel Segmentation

##Watershed Segmentation
"""

# Import necessary libraries
import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/image12.jpg')

# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply threshold to obtain a binary image
ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Noise removal using morphological opening
kernel = np.ones((3, 3), np.uint8)
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations = 2)

# Background area detection
sure_bg = cv2.dilate(opening, kernel, iterations=3)

# Foreground area detection
dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
ret, sure_foreground = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)

# Unknown region detection
sure_foreground = np.uint8(sure_foreground)
unknown = cv2.subtract(sure_bg, sure_foreground)

# Marker labelling
ret, markers = cv2.connectedComponents(sure_foreground)

# Add one to all labels so that sure background is not 0, but 1
markers = markers + 1

# Label the unknown region as 0
markers[unknown == 255] = 0

# Apply watershed algorithm
markers = cv2.watershed(img, markers)

# Outline the segmented objects
img[markers == -1] = [255,0,0]

# Display the results
plt.imshow(img)
plt.show()

"""#Mean-Shift Segmentation"""

# Import necessary libraries
import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/image12.jpg')

# Convert to a and b color space
new_image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
new_image = cv2.cvtColor(new_image, cv2.COLOR_RGB2Lab)

# Define the parameters for the mean shift algorithm
spatial_radius = 10
color_radius = 20
max_pyr_level = 1

# Apply the mean shift algorithm
meanshift = cv2.pyrMeanShiftFiltering(new_image, sp = spatial_radius, sr = color_radius, maxLevel = max_pyr_level)

# Convert the mean shift result back to RGB color space
meanshift = cv2.cvtColor(meanshift, cv2.COLOR_LAB2RGB)

# Display the results
plt.subplot(121),plt.imshow(img),plt.title('Original Image')
plt.subplot(122),plt.imshow(meanshift),plt.title('Mean Shift Image')
plt.show()

"""#Graph-Based Segmentation"""

# Import necessary libraries
import cv2
import numpy as np
import networkx as nx
from skimage.segmentation import slic
from skimage.segmentation import mark_boundaries
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/image12.jpg')

# Apply SLIC algorithm to obtain superpixels
segments = slic(img, n_segments=200, compactness=10)

# Create graph
graph = nx.Graph()

# Add nodes to graph
for i in range(segments.max() + 1):
    graph.add_node(i, size=len(np.where(segments == i)[0]))

# Add weight to edges connecting superpixels
for (i, j) in np.ndindex(segments.shape[:2]):
    if i < segments.shape[0] - 1 and j < segments.shape[1] - 1:
        weight1 = np.sum((img[i, j] - img[i + 1, j]) ** 2)
        weight2 = np.sum((img[i, j] - img[i, j + 1]) ** 2)
        if segments[i, j] != segments[i + 1, j]:
            graph.add_edge(segments[i, j], segments[i + 1, j], weight=weight1)
        if segments[i, j] != segments[i, j + 1]:
            graph.add_edge(segments[i, j], segments[i, j + 1], weight=weight2)

# Apply minimum spanning tree algorithm to segment the data
tree = nx.minimum_spanning_tree(graph)

# Create segment grid with the same shape as the original image
segment_grid = np.zeros_like(segments, dtype=int)

# Assign a segment to each pixel in the segment grid
for i in range(segments.shape[0]):
    for j in range(segments.shape[1]):
        for node in nx.node_connected_component(tree, segments[i, j]):
            segment_grid[i, j] = node

# Display the results
fig = plt.figure(figsize=(8, 4))
ax1 = plt.subplot(1, 2, 1)
ax1.imshow(mark_boundaries(img, segments))
ax2 = plt.subplot(1, 2, 2)
ax2.imshow(mark_boundaries(img, segment_grid))
plt.show()

"""#Region Growing Segmentation"""

# Import necessary libraries
import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/image12.jpg')
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Define the starting seed point for region growing
x_start, y_start = 200, 300

# Define the threshold value for region growing
threshold = 10

# Define the region growing function
def region_grow(img, seed, threshold):
    # Define a queue to store the neighboring pixels of the seed point
    queue = []
    queue.append(seed)

    # Define a visited matrix to track which pixels have been visited
    visited = np.zeros_like(img)

    # Define a list to store the segmented pixels
    segmented = []

    # Define the conditions for region growing
    while len(queue) > 0:
        # Pop the first pixel from the queue
        (x, y) = queue.pop(0)

        # Check if the pixel has already been visited
        if visited[x, y] == 1:
            continue

        # Check if the pixel intensity is within the threshold
        if abs(int(img[x,y])-int(img[x_start, y_start])) <= threshold:
            segmented.append((x, y))

            # Add the neighboring pixels to the queue
            if x > 0:
                queue.append((x-1, y))
            if x < img.shape[0] - 1:
                queue.append((x+1, y))
            if y > 0:
                queue.append((x, y-1))
            if y < img.shape[1] - 1:
                queue.append((x, y+1))

        # Mark the pixel as visited
        visited[x, y] = 1

    # Convert the segment list into a numpy array
    segmented = np.array(segmented)

    return segmented

# Perform region growing segmentation
segmented = region_grow(img_gray, (x_start, y_start), threshold)

# Colorize the segmented region with blue color
output = np.zeros_like(img)
output[segmented[:,0], segmented[:,1]] = (255, 0, 0)

# Create a mask for the segmented region
mask = np.zeros_like(img_gray)
for (x, y) in segmented:
    mask[x, y] = 255

# Combine the input image and the mask to create the output image
output = cv2.bitwise_and(img, img, mask=mask)

# Display the results
plt.subplot(121),plt.imshow(img),plt.title('Original Image')
plt.subplot(122),plt.imshow(output),plt.title('Segmented Image')
plt.show()

"""#Superpixel Segmentation"""

# Import necessary libraries
import cv2
import numpy as np
from skimage.segmentation import slic
from matplotlib import pyplot as plt

# Load the image
img = cv2.imread('/content/image12.jpg')

# Apply the SLIC algorithm to obtain superpixels
segments = slic(img, n_segments=100, compactness=10)

# Colorize the superpixels
output = np.zeros_like(img)
for i in np.unique(segments):
    output[segments == i] = np.average(img[segments == i], axis=0)

# Display the results
plt.subplot(121),plt.imshow(img),plt.title('Original Image')
plt.subplot(122),plt.imshow(output),plt.title('Superpixel Image')
plt.show()

"""# Biểu đồ Histogram cho các thuật toán khác: dựa vào các chỉ số hiệu xuất Precision, Recall, F1-score và IOU (Intersection over Union)."""

import cv2
import numpy as np
def calculate_metrics(gt_mask, pred_mask):
    # Compute the True Positive (TP), False Positive (FP) and False Negative (FN) counts
    TP = np.sum(np.logical_and(gt_mask, pred_mask))
    FP = np.sum(np.logical_and(np.logical_not(gt_mask), pred_mask))
    FN = np.sum(np.logical_and(gt_mask, np.logical_not(pred_mask)))
    # Compute the Precision, Recall and F1-score
    precision = TP / (TP + FP)
    recall = TP / (TP + FN)
    f1_score = 2 * precision * recall / (precision + recall)
    # Compute the Intersection over Union (IoU)
    intersection = np.sum(np.logical_and(gt_mask, pred_mask))
    union = np.sum(np.logical_or(gt_mask, pred_mask))
    iou = intersection / union
    return precision, recall, f1_score, iou
# Load the ground truth and predicted masks for each algorithm
gt_mask = cv2.imread('/content/image12.jpg', cv2.IMREAD_GRAYSCALE)
pred_mask_algom1 = cv2.imread('/content/WatershedSegmentation.png', cv2.IMREAD_GRAYSCALE)
pred_mask_algom1_resized = cv2.resize(pred_mask_algom1, (405, 405))
precision1, recall1, f1_score1, iou1 = calculate_metrics(gt_mask, pred_mask_algom1_resized)
pred_mask_algom2 = cv2.imread('/content/Mean Shift Image.png', cv2.IMREAD_GRAYSCALE)
pred_mask_algom2_resized = cv2.resize(pred_mask_algom2, (405, 405))
precision2, recall2, f1_score2, iou2 = calculate_metrics(gt_mask, pred_mask_algom2_resized)
gt_mask_resized = cv2.resize(gt_mask, (299, 295))
precision2, recall2, f1_score2, iou2 = calculate_metrics(gt_mask_resized, pred_mask_algom2)
pred_mask_algom3 = cv2.imread('/content/Graph-BasedSegmentation.png', cv2.IMREAD_GRAYSCALE)
pred_mask_algom3_resized = cv2.resize(pred_mask_algom3, (405, 405))
precision3, recall3, f1_score3, iou3 = calculate_metrics(gt_mask, pred_mask_algom3_resized)
pred_mask_algom4 = cv2.imread('/content/Region Growing Segmentation.png', cv2.IMREAD_GRAYSCALE)
pred_mask_algom4_resized = cv2.resize(pred_mask_algom4, (405, 405))
precision4, recall4, f1_score4, iou4 = calculate_metrics(gt_mask, pred_mask_algom4_resized)
pred_mask_algom5 = cv2.imread('/content/Superpixel Segmentation.png', cv2.IMREAD_GRAYSCALE)
pred_mask_algom5_resized = cv2.resize(pred_mask_algom5, (405, 405))
precision5, recall5, f1_score5, iou5 = calculate_metrics(gt_mask, pred_mask_algom5_resized)
# Print the computed metrics for each algorithm
print("Algorithm 1 - Precision: {:.4f}, Recall: {:.4f}, F1-score: {:.4f}, IoU: {:.4f}".format(precision1, recall1, f1_score1, iou1))
print("Algorithm 2 - Precision: {:.4f}, Recall: {:.4f}, F1-score: {:.4f}, IoU: {:.4f}".format(precision2, recall2, f1_score2, iou2))
print("Algorithm 3 - Precision: {:.4f}, Recall: {:.4f}, F1-score: {:.4f}, IoU: {:.4f}".format(precision3, recall3, f1_score3, iou3))
print("Algorithm 4 - Precision: {:.4f}, Recall: {:.4f}, F1-score: {:.4f}, IoU: {:.4f}".format(precision4, recall4, f1_score4, iou4))
print("Algorithm 5 - Precision: {:.4f}, Recall: {:.4f}, F1-score: {:.4f}, IoU: {:.4f}".format(precision5, recall5, f1_score5, iou5))

import matplotlib.pyplot as plt

# Create lists of metrics for each algorithm
precision_list = [precision1, precision2, precision3, precision4, precision5]
recall_list = [recall1, recall2, recall3, recall4, recall5]
f1_list = [f1_score1, f1_score2, f1_score3, f1_score4, f1_score5]
iou_list = [iou1, iou2, iou3, iou4, iou5]

# Combine all lists into one list
all_metrics = [precision_list, recall_list, f1_list, iou_list]

# Set labels for each algorithm
labels = ['Algorithm 1', 'Algorithm 2', 'Algorithm 3', 'Algorithm 4', 'Algorithm 5']

# Plot combined histogram
plt.hist(all_metrics, bins=10, label=labels)
plt.xlabel('Metrics')
plt.ylabel('Count')
plt.title('Metrics Distribution for 5 Segmentation Algorithms')
plt.legend()
plt.show()